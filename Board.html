<html>
<head>
	<title>KiChess</title>
	<link rel="icon" href="assets/whitePieces/rook.png">
</head>

<style>
	#chessBoard{
		width: 800px;
		height: 800px;
		border: 2px solid black; 
		opacity: 1.0
	}
	
	.square{
		position: relative;
		padding: 0; 
		margin: 0;
		width: 12.5%;
		height: 12.5%;
		top: 0;
		left: 0;
	}
	
	#promotionOverlay{
		position: absolute;
		top: 110px;
		left: 200px;
		border: 2px solid ;
		border-color: #000000;
		display: none;
	}	
	
	#promotionOverlayBlack{
		position: absolute;
		top: 595px;
		left: 200px;
		border: 2px solid ;
		border-color: #000000;
		display: none;
	}
	
	.promo{
		background-color: #cccccc
	
	}

	img
	{
		position: absolute;
		top: 0;
		left: 0;
	}
	
	.overlay{
		position: absolute;
		opacity: 1;
		top: 0;	
		left: 0;
		height: 100%;
		width: 100%;
	}
	
	.wsqr {
		background-color: #ffffb0;
	}
	.bsqr {
		background-color: #5c3f2e;
	}



</style>

<script type="text/javascript">

	var gamestate = "________;________;________;________;________;________;________;________;";
	var extendedState = {
		"isWhitesTurn": true,
		// represent allowed castling options:
		"a1": true,
		"h1": true,
		"a8": true,
		"h8": true,
		"EnpassanablePawn": false,
		"StateRepetitionCounter": {}
	}	
	var gameMetaData = {
		"isWhiteHuman": true,
		"isBlackHuman": true,
		"lastMovedPieceFrom": null,
		"lastMovedPieceTo": null
	}
	
	function calculateBoardState(state, coord, piece){
		
		var colNumber = coord[0].charCodeAt(0) - 96; // Col is given by leading letter. Convert this to integer from 1-8
		var rowNumber = Number(coord[1]); 
		
		var position = 9 * (8 - rowNumber) + colNumber - 1;
			
		return( state.substring(0, position) + piece + state.substring(position + 1) );
	}
	
	function transCoords(coord, y, x){
		var newRank = coord[0].charCodeAt(0) - 96 + y; 
		var newCol  = Number(coord[1]) + x;

		if ( newCol < 1 ||  newCol > 8 ||  newRank < 1 || newRank > 8){
			return null; // off the board
		}else{
			 return(String.fromCharCode(newRank + 96) + newCol);
		}
	}
	
	function amIInCheck(board, isWhiteTeam)
	{
		// Overview of logic: start from the king and see if the king is in vision by an enemy piece
		// team == true -> white 
		
		// Get coordinates of the king.
		var kingIndex = isWhiteTeam ? board.indexOf('k') : board.indexOf('K'); // position of king in string
		console.log("index: " + kingIndex);
		
		var letterCoord =  (kingIndex % 9) + 1 ;
		var numberCoord =  (8 -  Math.floor(kingIndex / 9));
		var kingsCoords = String.fromCharCode(letterCoord + 96) + numberCoord;
		console.log("I think the king is at: " + kingsCoords);

		function getPiece2(board, coordinate){

			var columnIndex = coordinate[0].charCodeAt(0) - 97; // Col is given by leading letter. This formula converts a char into its corresponding integer from 0-7
			var rowContents = board.split(";")[8 - coordinate[1]]; // Rows are enumerated 'backwards' in the gamestate to the coords.
			
			var cellContent = rowContents[columnIndex];      
			
			return cellContent;
		}

		// Return the coordinates of an ENEMY PIECE (if any), at the end of the line (x,y) diagonal from startingCoord
		function getVisibleEnemyPiece(board, startingCoord, x, y){

			var iter = 1;
			var newCoords = transCoords(startingCoord, x * iter, y * iter);
			while( newCoords ){
				if(getPiece2(board, newCoords) !== '_'){
				
					var visiblePiece = getPiece2(board, newCoords);
					
					var isWhitePiece = (visiblePiece === visiblePiece.toLowerCase());
					var isEnemyPiece = !(isWhitePiece === isWhiteTeam);
					
					if(isEnemyPiece){
						return {piece: visiblePiece, coords: newCoords};
					}else{
						return null;
					}
				}
				iter++;
				newCoords = transCoords(kingsCoords, x * iter, y * iter);
			}	
			return null;
		}
		
		// Evaluate Threats:
		
		// Threatened on diagonals:
		var allVisibleDiagonals = [getVisibleEnemyPiece(board, kingsCoords, +1, +1), getVisibleEnemyPiece(board, kingsCoords, +1, -1), 
								   getVisibleEnemyPiece(board, kingsCoords, -1, +1), getVisibleEnemyPiece(board, kingsCoords, -1, -1)];		
		for( var visibleEnemy of allVisibleDiagonals){
			if( !visibleEnemy ){ continue; } // Catch possible null value error here..
			if( ['b','B','q','Q'].includes(visibleEnemy.piece) ){ return visibleEnemy.coords }
		}
		
		// Threats vertically / horizontally
		var allVisibleDiagonals = [getVisibleEnemyPiece(board, kingsCoords, +1, 0), getVisibleEnemyPiece(board, kingsCoords, 0, -1), 
								   getVisibleEnemyPiece(board, kingsCoords, -1, 0), getVisibleEnemyPiece(board, kingsCoords, 0, +1)];		
		for( var visibleEnemy of allVisibleDiagonals){
			if( !visibleEnemy ){ continue; } // Catch possible null value error here..
			if( ['r','R','q','Q'].includes(visibleEnemy.piece) ){ return visibleEnemy.coords }
		}
		
		// Threats from Pawns:
		var directionOfThreateningPawn = (isWhiteTeam ? 1 : -1 );
		
		if(isWhiteTeam){
			if( transCoords(kingsCoords, +1,  +1) && getPiece2(board, transCoords(kingsCoords, +1,  +1)) === 'P'){ return transCoords(kingsCoords, +1,  +1)} ;
			if( transCoords(kingsCoords, -1,  +1) && getPiece2(board, transCoords(kingsCoords, -1,  +1)) === 'P'){ return transCoords(kingsCoords, -1,  +1)} ;
		}else{
			if( transCoords(kingsCoords, +1,  -1) && getPiece2(board, transCoords(kingsCoords, +1,  -1)) === 'p'){ return transCoords(kingsCoords, +1,  -1)} ;
			if( transCoords(kingsCoords, -1,  -1) && getPiece2(board, transCoords(kingsCoords, -1,  -1)) === 'p'){ return transCoords(kingsCoords, -1,  -1)} ;
		}

		
		// Threats from knights:
		var possibleKnightCoords = [transCoords(kingsCoords, +1,  +2), transCoords(kingsCoords, +1,  -2), 
									transCoords(kingsCoords, -1,  +2), transCoords(kingsCoords, -1,  -2), 
									transCoords(kingsCoords, +2,  +1), transCoords(kingsCoords, +2,  -1), 
									transCoords(kingsCoords, -2,  +1), transCoords(kingsCoords, -2,  -1)];		
		for( var possCoords of possibleKnightCoords){
			if( !possCoords ){ continue; } // Catch possible null value error here..
			
			 
			if(  isWhiteTeam   && (getPiece2(board, possCoords) === 'N') ){ return possCoords } 
			if( (!isWhiteTeam) && (getPiece2(board, possCoords) === 'n') ){ return possCoords } 

		}
		
		// Finally, threats from king!
		var allCoords = [transCoords(kingsCoords, +1, +1), transCoords(kingsCoords, +1, +0), transCoords(kingsCoords, +1, -1), transCoords(kingsCoords, +0, +1),	
						 transCoords(kingsCoords, +0, -1), transCoords(kingsCoords, -1, -1), transCoords(kingsCoords, -1, +0), transCoords(kingsCoords, -1, +1) ];

		for(var possCoords of allCoords)
		{ 
			if( !possCoords ){ continue; }
			if( (getPiece2(board, possCoords) === 'K') || (getPiece2(board, possCoords) === 'k') ){
				return possCoords;
			}
		}
		
		// else
		return false;
	}
	
	function getLegalMoves(coord){
			
		var piece = getPiece(coord);
		var CandidateLegalMoves = {};
		
		// Logic works as follows:
		// A hash table called CandidateLegalMoves with keys of the coordinate you click on to make the move is defined.
		// The hash table contains an object with properties: gamestate = string rep of the board
		// Assume that enpassanable will be no unless specified.
		// Example:
		// CandidateLegalMoves[newCoords] = {gamestate : calculateBoardState(calculateBoardState(gamestate, coord, '_'), newCoords, piece), extendedStateChange : {"EnpassanablePawn": 'h1'}, promotion: h8};

		// Auxillary functions:
		function isEnemyPiece(piece){
			if(piece === "_") {return false;}
			
			var isWhitePiece  = (piece == piece.toLowerCase());
			return !(isWhitePiece === extendedState.isWhitesTurn);
		}
		
		
		function findAllMovesInLine(x,y){
			var iter = 1;
			var newCoords = transCoords(coord, x * iter, y * iter);
			while( newCoords ){
				if(getPiece(newCoords) == '_'){
					CandidateLegalMoves[newCoords] = { gamestate : calculateBoardState(calculateBoardState(gamestate, coord, '_'), newCoords, piece) };
				}else{ 
					if(isEnemyPiece(getPiece(newCoords))){
						CandidateLegalMoves[newCoords] = { gamestate : calculateBoardState(calculateBoardState(gamestate, coord, '_'), newCoords, piece) };
						break; // If can capture, cant carry on after.
					}else{
						break; // Cannot take own piece
					}
				}
				iter++;
				newCoords = transCoords(coord,x * iter, y * iter);
			}
		}

		/////////////////////////////	MAIN LOGIC	///////////////////////////////////
		if( piece == 'R' || piece == 'r' ){  		
		
		findAllMovesInLine(0,1);
			findAllMovesInLine(1,0);
			findAllMovesInLine(0,-1);
			findAllMovesInLine(-1,0);
			
			// Disable castling after a rook moves.
			if( ['a1','a8','h1','h8'].includes(coord) ){ // indicates rook has moved from starting square (or is in some other rooks square, which doesnt matter)
				console.log("MOVING ROOK FROM START");
				Object.keys(CandidateLegalMoves).forEach(function (movelocation) {	
					var disabledCastling = {};
					disabledCastling[coord] = false;
					
					CandidateLegalMoves[movelocation]['extendedStateChange'] = disabledCastling;
					console.log(CandidateLegalMoves[movelocation]);
				})
			}
		}
		if( piece == 'N' || piece == 'n' ){  
			
			var allCoords = [transCoords(coord, 1, 2), transCoords(coord, 1, -2), transCoords(coord, -1, 2), transCoords(coord, -1, -2),	
							 transCoords(coord, 2, 1), transCoords(coord, 2, -1), transCoords(coord, -2, 1), transCoords(coord, -2, -1) ];
			
			for(var possCoords of allCoords){
				if( !possCoords ){ continue; } // Catch possible null value error here..
				if( (getPiece(possCoords) == '_') || isEnemyPiece(getPiece(possCoords)) ){
					CandidateLegalMoves[possCoords] = { gamestate : calculateBoardState(calculateBoardState(gamestate, coord, '_'), possCoords, piece) };
				}		
			}
		} 	
		if( piece == 'B' || piece == 'b' ){  

			findAllMovesInLine(+1,+1);
			findAllMovesInLine(+1,-1);
			findAllMovesInLine(-1,+1);	
			findAllMovesInLine(-1,-1);
		}
		if( piece == 'K' || piece == 'k' ){  
			var allCoords = [transCoords(coord, 1, 1), transCoords(coord, 1, 0), transCoords(coord, 1, -1), transCoords(coord, 0, 1),	
						transCoords(coord, 0, -1), transCoords(coord, -1, -1), transCoords(coord, -1, 0), transCoords(coord, -1, 1) ];
				
			for(var possCoords of allCoords){
				// Possible null value error here..
				if( !possCoords ){ continue; }
				if( (getPiece(possCoords) == '_') || isEnemyPiece(getPiece(possCoords)) ){
					
					// Moving the king prevents castling
					var extendedStateChange = {}
					if( piece == 'k' ){  
						extendedStateChange['a1'] = false;
						extendedStateChange['a8'] = false;
					}
					if( piece == 'K'){
						extendedStateChange['h1'] = false;
						extendedStateChange['h8'] = false;
					}
					CandidateLegalMoves[possCoords] = { gamestate : calculateBoardState(calculateBoardState(gamestate, coord, '_'), possCoords, piece), extendedStateChange : extendedStateChange };
				}		
			}
			
			// Castling:
			if( piece === 'k'){
				
				// White long (left) side castle.  king starts at E1, and moves to B1
				if(extendedState['a1']){
					if( (getPiece('b1')==='_') && (getPiece('c1')==='_') && (getPiece('d1')==='_') ){ 
						// king starts at E1, and moves to B1. Rook starts at A1 and finishes at B1
						// Verify not initially in check, and all intermediate squares are not threatened.
						if( ! amIInCheck(gamestate, extendedState.isWhitesTurn) ){
						
							var intState1 = calculateBoardState(calculateBoardState(gamestate, 'e1', '_'), 'd1', 'k');
							if( !amIInCheck(intState1, extendedState.isWhitesTurn) ){
								
								var intState2 = calculateBoardState(calculateBoardState(intState1, 'd1', '_'), 'c1', 'k');
								if( !amIInCheck(intState2, extendedState.isWhitesTurn) ){
									
									var intState3 = calculateBoardState(calculateBoardState(intState2, 'c1', '_'), 'b1', 'k'); // no need to check this state 
									var finalState = calculateBoardState(calculateBoardState(intState3, 'a1', '_'), 'c1', 'r'); // This gets checked later
									
									CandidateLegalMoves['a1'] = { gamestate : finalState, extendedStateChange : {a1: false, h1: false} };
								}
							}
						}
					}
				}
				
				// White short (right) side castle. 
				if(extendedState['h1']){
					if( (getPiece('f1')==='_') && (getPiece('g1')==='_')  ){ 
						// king starts at e1, and moves to g1. Rook starts at h1 and finishes at f1
						// Verify not initially in check, and all intermediate squares are not threatened.
						if( ! amIInCheck(gamestate, extendedState.isWhitesTurn) ){
						
							var intState1 = calculateBoardState(calculateBoardState(gamestate, 'e1', '_'), 'f1', 'k');
							if( !amIInCheck(intState1, extendedState.isWhitesTurn) ){
								
								var intState2 = calculateBoardState(calculateBoardState(intState1, 'f1', '_'), 'g1', 'k'); // no need to check this state 
								var finalState = calculateBoardState(calculateBoardState(intState2, 'h1', '_'), 'f1', 'r'); // This gets checked later
								
								CandidateLegalMoves['h1'] = { gamestate : finalState, extendedStateChange : {a1: false, h1: false} };
							}
						}
					}
				}
			}else{
				// black long (left) side castle.  king starts at e8, and moves to b8
				if(extendedState['a8']){
					if( (getPiece('b8')==='_') && (getPiece('c8')==='_') && (getPiece('d8')==='_') ){ 
						// king starts at E1, and moves to B1. Rook starts at A1 and finishes at B1
						// Verify not initially in check, and all intermediate squares are not threatened.
						if( ! amIInCheck(gamestate, extendedState.isWhitesTurn) ){
						
							var intState1 = calculateBoardState(calculateBoardState(gamestate, 'e8', '_'), 'd8', 'K');
							if( !amIInCheck(intState1, extendedState.isWhitesTurn) ){
								
								var intState2 = calculateBoardState(calculateBoardState(intState1, 'd8', '_'), 'c8', 'K');
								if( !amIInCheck(intState2, extendedState.isWhitesTurn) ){
									
									var intState3 = calculateBoardState(calculateBoardState(intState2, 'c8', '_'), 'b8', 'K'); // no need to check this state 
									var finalState = calculateBoardState(calculateBoardState(intState3, 'a8', '_'), 'c8', 'R'); // This gets checked later
									
									CandidateLegalMoves['a8'] = { gamestate : finalState, extendedStateChange : {a8: false, h8: false} };
								}
							}
						}
					}
				}
				// black short (right) side castle. 
				if(extendedState['h8']){
					if( (getPiece('f8')==='_') && (getPiece('g8')==='_')  ){ 
						// king starts at e8, and moves to g8. Rook starts at h8 and finishes at f8
						// Verify not initially in check, and all intermediate squares are not threatened.
						if( ! amIInCheck(gamestate, extendedState.isWhitesTurn) ){
						
							var intState1 = calculateBoardState(calculateBoardState(gamestate, 'e8', '_'), 'f8', 'K');
							if( !amIInCheck(intState1, extendedState.isWhitesTurn) ){
								
								var intState2 = calculateBoardState(calculateBoardState(intState1, 'f8', '_'), 'g8', 'K'); // no need to check this state 
								var finalState = calculateBoardState(calculateBoardState(intState2, 'h8', '_'), 'f8', 'R'); // This gets checked later
								
								CandidateLegalMoves['h8'] = { gamestate : finalState, extendedStateChange : {a8: false, h8: false} };
							}
						}
					}
				}
			}

			
		} 
		if( piece == 'Q' || piece == 'q' ){  
			findAllMovesInLine(+1,+1);
			findAllMovesInLine(+1,-1);
			findAllMovesInLine(-1,+1);	
			findAllMovesInLine(-1,-1);
			findAllMovesInLine(0,1);
			findAllMovesInLine(1,0);
			findAllMovesInLine(0,-1);
			findAllMovesInLine(-1,0);
		} 		
		if( piece === 'p' || piece === 'P' ){ 
			
			var direction = 1;
			if(piece === "P"){
				direction = -1;
			}
			
			var newCoords = transCoords(coord, 0, direction * 1);
			
			// Pawn can move forwards
			if( newCoords && getPiece(newCoords) === "_" ){
				
				var promotion = false
				if(newCoords.match('.8') || newCoords.match('.1')){ promotion = newCoords; }
				CandidateLegalMoves[newCoords] = { gamestate : calculateBoardState(calculateBoardState(gamestate, coord, '_'), newCoords, piece), promotion: promotion };
				
				// Can move 2 spaces on first move:
				if((piece === 'p' && coord.match('.2')) || (piece === 'P' && coord.match('.7'))){
					newCoords = transCoords(coord, 0, direction * 2);
					if( newCoords && getPiece(newCoords) === "_" ){
						CandidateLegalMoves[newCoords] = { gamestate : calculateBoardState(calculateBoardState(gamestate, coord, '_'), newCoords, piece), extendedStateChange : {EnpassanablePawn: transCoords(coord, 0, direction * 1)}};
					}	
				}
			}			
			
			// Pawn can take diagonally - and enpassant
			newCoords = transCoords(coord, 1, direction * 1);
			if(  newCoords && (isEnemyPiece(getPiece(newCoords)) || (newCoords === extendedState.EnpassanablePawn)) )
			{
				var promotion = false
				if(newCoords.match('.8') || newCoords.match('.1')){ promotion = newCoords; }
				CandidateLegalMoves[newCoords] = { gamestate : calculateBoardState(calculateBoardState(gamestate, coord, '_'), newCoords, piece), promotion: promotion };
				
				// In the event of en-passant, also need to remove the other pawn 
				if(newCoords === extendedState.EnpassanablePawn){
					var pawnToDeleteCoords =  transCoords(extendedState.EnpassanablePawn, 0, (-direction)*1 );
					CandidateLegalMoves[newCoords].gamestate = calculateBoardState(CandidateLegalMoves[newCoords].gamestate, pawnToDeleteCoords , '_');
				}
			}
			
			newCoords = transCoords(coord, -1, direction * 1);
			if(  newCoords && (isEnemyPiece(getPiece(newCoords)) || (newCoords === extendedState.EnpassanablePawn) ) )
			{
				var promotion = false
				if(newCoords.match('.8') || newCoords.match('.1')){ promotion = newCoords; }
				CandidateLegalMoves[newCoords] = { gamestate : calculateBoardState(calculateBoardState(gamestate, coord, '_'), newCoords, piece), promotion: promotion };
				
				// In the event of en-passant, also need to remove the other pawn 
				if(newCoords === extendedState.EnpassanablePawn){
					var pawnToDeleteCoords =  transCoords(extendedState.EnpassanablePawn, 0, (-direction)*1 );
					CandidateLegalMoves[newCoords].gamestate = calculateBoardState(CandidateLegalMoves[newCoords].gamestate, pawnToDeleteCoords , '_');
				}
			}		
		 } 		 
		if( piece == '_'){
			previouslySelectedSquare = null;
			throw "This should not be possible - trying to move an empty square"
		}
		
		// Validate moves are not in checks
		for (const move of Object.keys(CandidateLegalMoves)){ 
			if(amIInCheck( CandidateLegalMoves[move].gamestate, extendedState.isWhitesTurn)){
				delete CandidateLegalMoves[move];
			}
		}
		
		return CandidateLegalMoves;
			
	}
	
	function markLegalMoves(coord){
	
		// Mark the newly selected square.
		var currentSquare = document.getElementById(coord);	
		currentSquare.innerHTML = '<img src="assets/SelectedSquare.png" class="overlay" >' +  currentSquare.innerHTML; // Show green selection
		
		var legalMoves = getLegalMoves(coord);
		for (const move of Object.keys(legalMoves)) {	
			var newSquare = document.getElementById(move);
			
			if(getPiece(move) !== "_")
			{
				newSquare.innerHTML += '<img src="assets/TakePiece.png" class="overlay" >'; 
			}else{
				newSquare.innerHTML += '<img src="assets/MovePiece.png" class="overlay" >'; 
				// TODO: special cases of castling and en-passant
			}	
		}	
	}
	
	function getPiece(coordinate){

		var columnIndex = coordinate[0].charCodeAt(0) - 97; // Col is given by leading letter. This formula converts a char into its corresponding integer from 0-7
		var rowContents = gamestate.split(";")[8 - coordinate[1]]; // Rows are enumerated 'backwards' in the gamestate to the coords.
		
		var cellContent = rowContents[columnIndex];      
		
		return cellContent;
	}
	
	var previouslySelectedSquare = null;
	var promotionContext = false;
	function selectSquare(coord){
	
		console.log("clicked on " + coord);
		if(promotionContext){
			// Close the pawn promotion window if player clicks off it.
			document.getElementById('chessboard').style.opacity = 1.0;
			document.getElementById('promotionOverlay').style.display = 'none';
			document.getElementById('promotionOverlayBlack').style.display = 'none';
			promotionContext = false;
		}
		
		
		if( gameMetaData.isWhitesTurn & (! extendedState.isWhiteHuman)){ console.log("White to play. Waiting for CPU"); return;} 
		if( gameMetaData.isBlacksTurn & (! extendedState.isBlackHuman)){ console.log("Black to play. Waiting for CPU"); return;} 
		
		if(previouslySelectedSquare == null){
		
			var newSelectedPiece = getPiece(coord);
			if(newSelectedPiece == '_'){		
				console.log("Selected empty square, nothing to do");
				return;
			}
			if(extendedState.isWhitesTurn && (newSelectedPiece != newSelectedPiece.toLowerCase())){		
				console.log("// white tried to select their opponent's piece");
				return;
			}			
			if(! extendedState.isWhitesTurn && (newSelectedPiece != newSelectedPiece.toUpperCase())){		
				console.log("// black tried to select their opponent's piece");
				return;
			}
			
			markLegalMoves(coord);
			previouslySelectedSquare = coord;
			
		}else{
			
			// Given that you have a currently selected piece:
				// if you clicked on another square and that is a legal move, then perform the move.
				// else, select the new piece
			
			// Clear previous overlay
			const elements = document.getElementsByClassName("overlay");
			while (elements.length > 0) elements[0].remove();
			
			// Validate the move is in the set of legal moves
			var legalMoves = getLegalMoves(previouslySelectedSquare);
			
			if(legalMoves[coord]){
				
				if(legalMoves[coord].promotion){
					
					promotionContext = previouslySelectedSquare + ';' + coord;
					document.getElementById('chessboard').style.opacity = 0.3;
					
					// Show pawn promotion window
					if(extendedState.isWhitesTurn){
						document.getElementById('promotionOverlay').style.display = 'block';
					}else{
						document.getElementById('promotionOverlayBlack').style.display = 'block';
					}
					return;
				}
				
				// Update gamestate and gameextended state.
				gamestate = legalMoves[coord].gamestate;
				
				extendedState['EnpassanablePawn'] = false;
				for (const property in legalMoves[coord].extendedStateChange) {
					
					// iterate over all properties $key of the object
					console.log("setting property " + property + " to value: " +  legalMoves[coord].extendedStateChange[property])
					extendedState[property] = legalMoves[coord].extendedStateChange[property];
				}
				
				renderBoard(gamestate);
				
				// Update turn 
				turnTransition();
				previouslySelectedSquare = null;
				
				
			}else{
				// Given they had a previously selected piece, they have not selcted a legal move for that peice.
				// Instead, just show the legal moves for that piece (via recursive call) 
				// TODO: if you click the same square, deselect it.
				
				previouslySelectedSquare = null;
				selectSquare(coord);
			}
		}
	}
	
	function startGame(){
		// Caps is black, lower case for white pieces. N = knight, K = king.
		var startingState = "RNBQKBNR;PPPPPPPP;________;________;________;________;pppppppp;rnbqkbnr;"
		extendedState =  {
			"isWhitesTurn": true,
			// represent allowed castling options:
			"a1": true,
			"h1": true,
			"a8": true,
			"h8": true,
			"EnpassanablePawn": false,
			"StateRepetitionCounter": {}
		}
		gamestate = startingState;
		renderBoard(startingState);

	}
	
	function renderBoard(state){
	
		var rows = state.split(';');
		var chessBoard = document.getElementsByClassName("square");
		
		var x = 0;
		for (const row of rows) {		
			for( const cell of row.split('')){
					
				if( cell == 'R' ){ chessBoard[x].innerHTML = '<img src="assets/blackPieces/rook.png" height = 100px width = 100px >' } 
				if( cell == 'N' ){ chessBoard[x].innerHTML = '<img src="assets/blackPieces/knight.png" height = 100px width = 100px >' } 
				if( cell == 'B' ){ chessBoard[x].innerHTML = '<img src="assets/blackPieces/bishop.png" height = 100px width = 100px >' } 
				if( cell == 'K' ){ chessBoard[x].innerHTML = '<img src="assets/blackPieces/king.png" height = 100px width = 100px >' } 
				if( cell == 'Q' ){ chessBoard[x].innerHTML = '<img src="assets/blackPieces/queen.png" height = 100px width = 100px >' } 
				if( cell == 'P' ){ chessBoard[x].innerHTML = '<img src="assets/blackPieces/pawn.png" height = 100px width = 100px >' } 
				
				if( cell == 'r' ){ chessBoard[x].innerHTML = '<img src="assets/whitePieces/rook.png" height = 100px width = 100px >' } 
				if( cell == 'n' ){ chessBoard[x].innerHTML = '<img src="assets/whitePieces/knight.png" height = 100px width = 100px >' } 
				if( cell == 'b' ){ chessBoard[x].innerHTML = '<img src="assets/whitePieces/bishop.png" height = 100px width = 100px >' } 
				if( cell == 'k' ){ chessBoard[x].innerHTML = '<img src="assets/whitePieces/king.png" height = 100px width = 100px >' } 
				if( cell == 'q' ){ chessBoard[x].innerHTML = '<img src="assets/whitePieces/queen.png" height = 100px width = 100px >' } 
				if( cell == 'p' ){ chessBoard[x].innerHTML = '<img src="assets/whitePieces/pawn.png" height = 100px width = 100px >' } 
				
				if( cell == '_' ){ chessBoard[x].innerHTML = '' } 
			
				x++
			}
		}
		
		var isInCheck = amIInCheck(state, !extendedState.isWhitesTurn);
		if(isInCheck){
			// Get Location of the King:
			var kingIndex = (!extendedState.isWhitesTurn) ? gamestate.indexOf('k') : gamestate.indexOf('K'); 
			var letterCoord =  (kingIndex % 9) + 1 ;
			var numberCoord =  (8 -  Math.floor(kingIndex / 9));
			var kingsCoords = String.fromCharCode(letterCoord + 96) + numberCoord;
			
			var checkSquare =  document.getElementById(kingsCoords);
			checkSquare.innerHTML = '<img src="assets/Check.png"height = 97px width = 97px, style = "opacity: 1"  >' +  checkSquare.innerHTML ;
			
			// var checkSquare2 =  document.getElementById(isInCheck);
			// checkSquare2.innerHTML = '<img src="assets/Check.png"height = 97px width = 97px  >' +  checkSquare2.innerHTML ;
		}
	}
	
	function turnTransition(){
		extendedState.isWhitesTurn = !(extendedState.isWhitesTurn);
		
		// TODO: See if in stalemate / checkmate
		// Use this to get next possible moves from this state.
		
		// get all allied piece (this is for speed)
		var referenceState;
		if(extendedState.isWhitesTurn){
			referenceState = gamestate.toLowerCase();
		}else{
			referenceState = gamestate.toUpperCase();
		}
		
		for (let x = 0; x < 72 ; x++) {
			if(referenceState[x] === '_' | referenceState[x] === ';'  ){continue;}
			if(referenceState[x] === gamestate[x]){
				// indicates is allied piece.
				// TODO: calculate coords.
				
				var letterCoord =  (x % 9) + 1 ;
				var numberCoord =  (8 -  Math.floor(x / 9));
				var currentPieceCoords = String.fromCharCode(letterCoord + 96) + numberCoord;
				
				if(Object.keys(getLegalMoves(currentPieceCoords)).length > 0){
					return;
				}
			}
		}
		console.log('no moves found');
		// TODO: handle stalemate / checkmate 
		if(amIInCheck(gamestate, extendedState.isWhitesTurn)){
			checkmate(extendedState.isWhitesTurn);
		}else{
			stalemate;
		}
		return
		
		// END TODO 
	}
	function checkmate(loosingTeamIsWhite){
		if(loosingTeamIsWhite){
			console.log('Black won!');
		}else{
			console.log('White won!');
		}
		
	}
	function stalemate(){
		Console.log("stalemate!")
	}
	function promotePawn(newPiece){
		
		document.getElementById('chessboard').style.opacity = 1.0;
		document.getElementById('promotionOverlay').style.display = 'none';
		document.getElementById('promotionOverlayBlack').style.display = 'none';
		
		// Process Move
		var previousPawnSquare = promotionContext.split(";")[0];
		var newSquare = promotionContext.split(";")[1];
		
		console.log(previousPawnSquare);
		gamestate = calculateBoardState(gamestate, newSquare, newPiece);
		gamestate = calculateBoardState(gamestate, previousPawnSquare, "_");
		
		renderBoard(gamestate);
		turnTransition();
		
		previouslySelectedSquare = null;
		promotionContext = false;
	}
	
</script>
<body>	
	<table id = "chessboard">
	  <tr>
		<td id="a8" onclick = selectSquare("a8") class="wsqr square"></td>
		<td id="b8" onclick = selectSquare("b8") class="bsqr square"></td>
		<td id="c8" onclick = selectSquare("c8") class="wsqr square"></td>
		<td id="d8" onclick = selectSquare("d8") class="bsqr square"></td>
		<td id="e8" onclick = selectSquare("e8") class="wsqr square"></td>
		<td id="f8" onclick = selectSquare("f8") class="bsqr square"></td>
		<td id="g8" onclick = selectSquare("g8") class="wsqr square"></td>
		<td id="h8" onclick = selectSquare("h8") class="bsqr square"></td>
	  </tr>  
	  <tr>
		<td id="a7" onclick = selectSquare("a7") class="bsqr square"></td>
		<td id="b7" onclick = selectSquare("b7") class="wsqr square"></td>
		<td id="c7" onclick = selectSquare("c7") class="bsqr square"></td>
		<td id="d7" onclick = selectSquare("d7") class="wsqr square"></td>
		<td id="e7" onclick = selectSquare("e7") class="bsqr square"></td>
		<td id="f7" onclick = selectSquare("f7") class="wsqr square"></td>
		<td id="g7" onclick = selectSquare("g7") class="bsqr square"></td>
		<td id="h7" onclick = selectSquare("h7") class="wsqr square"></td>
	  </tr>  
	  <tr>
		<td id="a6" onclick = selectSquare("a6") class="wsqr square"></td>
		<td id="b6" onclick = selectSquare("b6") class="bsqr square"></td>
		<td id="c6" onclick = selectSquare("c6") class="wsqr square"></td>
		<td id="d6" onclick = selectSquare("d6") class="bsqr square"></td>
		<td id="e6" onclick = selectSquare("e6") class="wsqr square"></td>
		<td id="f6" onclick = selectSquare("f6") class="bsqr square"></td>
		<td id="g6" onclick = selectSquare("g6") class="wsqr square"></td>
		<td id="h6" onclick = selectSquare("h6") class="bsqr square"></td>
	  </tr>  
	  <tr>
		<td id="a5" onclick = selectSquare("a5") class="bsqr square"></td>
		<td id="b5" onclick = selectSquare("b5") class="wsqr square"></td>
		<td id="c5" onclick = selectSquare("c5") class="bsqr square"></td>
		<td id="d5" onclick = selectSquare("d5") class="wsqr square"></td>
		<td id="e5" onclick = selectSquare("e5") class="bsqr square"></td>
		<td id="f5" onclick = selectSquare("f5") class="wsqr square"></td>
		<td id="g5" onclick = selectSquare("g5") class="bsqr square"></td>
		<td id="h5" onclick = selectSquare("h5") class="wsqr square"></td>
	  </tr>  
	  <tr>
		<td id="a4" onclick = selectSquare("a4") class="wsqr square"></td>
		<td id="b4" onclick = selectSquare("b4") class="bsqr square"></td>
		<td id="c4" onclick = selectSquare("c4") class="wsqr square"></td>
		<td id="d4" onclick = selectSquare("d4") class="bsqr square"></td>
		<td id="e4" onclick = selectSquare("e4") class="wsqr square"></td>
		<td id="f4" onclick = selectSquare("f4") class="bsqr square"></td>
		<td id="g4" onclick = selectSquare("g4") class="wsqr square"></td>
		<td id="h4" onclick = selectSquare("h4") class="bsqr square"></td>
	  </tr>  
	  <tr>
		<td id="a3" onclick = selectSquare("a3") class="bsqr square"></td>
		<td id="b3" onclick = selectSquare("b3") class="wsqr square"></td>
		<td id="c3" onclick = selectSquare("c3") class="bsqr square"></td>
		<td id="d3" onclick = selectSquare("d3") class="wsqr square"></td>
		<td id="e3" onclick = selectSquare("e3") class="bsqr square"></td>
		<td id="f3" onclick = selectSquare("f3") class="wsqr square"></td>
		<td id="g3" onclick = selectSquare("g3") class="bsqr square"></td>
		<td id="h3" onclick = selectSquare("h3") class="wsqr square"></td>
	  </tr>  
	  <tr>
		<td id="a2" onclick = selectSquare("a2") class="wsqr square"></td>
		<td id="b2" onclick = selectSquare("b2") class="bsqr square"></td>
		<td id="c2" onclick = selectSquare("c2") class="wsqr square"></td>
		<td id="d2" onclick = selectSquare("d2") class="bsqr square"></td>
		<td id="e2" onclick = selectSquare("e2") class="wsqr square"></td>
		<td id="f2" onclick = selectSquare("f2") class="bsqr square"></td>
		<td id="g2" onclick = selectSquare("g2") class="wsqr square"></td>
		<td id="h2" onclick = selectSquare("h2") class="bsqr square"></td>
	  </tr>  
	  <tr>
		<td id="a1" onclick = selectSquare("a1") class="bsqr square"></td>
		<td id="b1" onclick = selectSquare("b1") class="wsqr square"></td>
		<td id="c1" onclick = selectSquare("c1") class="bsqr square"></td>
		<td id="d1" onclick = selectSquare("d1") class="wsqr square"></td>
		<td id="e1" onclick = selectSquare("e1") class="bsqr square"></td>
		<td id="f1" onclick = selectSquare("f1") class="wsqr square"></td>
		<td id="g1" onclick = selectSquare("g1") class="bsqr square"></td>
		<td id="h1" onclick = selectSquare("h1") class="wsqr square"></td>
	  </tr>
	</table>

	<button onclick="startGame()" > Start Game </button>
</body>
<table >
	<tr id = "promotionOverlay"; style='background-color: #ffffff'>
		<td class="promo" onclick = promotePawn('n')> <img src="assets/whitePieces/knight.png" style='position: relative'> </td>
		<td class="promo" onclick = promotePawn('b')> <img src="assets/whitePieces/bishop.png" style='position: relative'> </td>
		<td class="promo" onclick = promotePawn('r')> <img src="assets/whitePieces/rook.png"   style='position: relative'> </td>
		<td class="promo" onclick = promotePawn('q')> <img src="assets/whitePieces/queen.png"  style='position: relative'> </td>
	</tr>	
	<tr id = "promotionOverlayBlack"; style='background-color: #ffffff'>
		<td class="promo" onclick = promotePawn('N')> <img src="assets/blackPieces/knight.png" style='position: relative'> </td>
		<td class="promo" onclick = promotePawn('B')> <img src="assets/blackPieces/bishop.png" style='position: relative'> </td>
		<td class="promo" onclick = promotePawn('R')> <img src="assets/blackPieces/rook.png"   style='position: relative'> </td>
		<td class="promo" onclick = promotePawn('Q')> <img src="assets/blackPieces/queen.png"  style='position: relative'> </td>
	</tr>
</table>
</html>